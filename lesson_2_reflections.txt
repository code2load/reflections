1. What happens when you initialize a repository? Why do you need to do it?Git creates hidden files required to track the state of the repository.Without performing an init, git won't be able to commit and fully track files.—--2. How is the staging area different from the working directory and the repository? What value do you think it offers?The working directory contains the files for the current checked out branch, which may have local changes yet to be committed, whereas the repository contains all commits. The staging area provides a intermediate place to group files that are ready to be committed, and are copied from the working directory via the “git add” command. When a commit is performed, files from the staging area are then committed to the repository. The staging area then is an intermediary between the working directory and repository, and provides a convenient way to group and isolate all files related to a logical change, so they can all be commited at once.---3. How can you use the staging area to make sure you have one commit per logical change?Files can be added from the working area to the staging area using the "git add" command. When a "git commit" is performed, all of the files in the staging area are commited together, excluding possibly unrelated changes in the working area, which have not been staged. To ensure one commit per logical change, be sure to stage eachfile related to the change using "git add" prior to performing "git commit".---4. What are some situations when branches would be helpful in keeping your history organized? How would branches help?Some situations: Making some exploratory changes without affecting the master branch, creating a "separate" version of an application with special features geared towards a particular client, making a version localized for a particular language.Branches allow you to freely make changes without impacting the original branch. The branch can remain separate, or be merged back in the source branch, allowing exploratory flexibility.---5. How do the diagrams help you visualize the branch structure?The diagrams reduce clutter and present a more simple abstract representation, without all the details listed by git which can obscure the basic structure of the graph.---6. What is the result of merging two branches together? Why do we represent it in the diagram the way we do?When two branches are merged, the changes are effectively combined. If merging branch A into the master branch, and the merge is successful and committed, a new commit is created and it becomes the new tip of the master branch. The branch label A can then be deleted without losing the changes that were introduced in branch A, as they are now effectively part of the master. In the diagrams, the new commit is depicted as pointing to both the previous tip of the master, and the tip of the branch that was merged in, to indicate that the content of both branches is represented.---7. What are the pros and cons of Git’s automatic merging vs. always doing merges manually?PRO: Saves a lot of work in easy cases. Doesn't attempt to resolve tricky conflicts,which could introduce an unintended mish-mash of code that may not work or compile anyway.CON: Hard cases with conflicts still require manual intervention.EOF